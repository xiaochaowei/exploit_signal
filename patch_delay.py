import numpy as np 
import datetime
import psycopg2
import scipy.io as sio

conn = psycopg2.connect(user = "patch", port = 5433)
cursor = conn.cursor()
def getPatchProfile(input, output ):
	products = set()
	clusters = {"chrome":{}, "firefox":{}, "thunderbird":{} }
#	pre_products = ['firefox', 'chrome', 'thunderbird', 'flashplayer']
	pre_products = ['firefox']
	with open(input , "r") as f:
		cve_list = f.read().split("\n")
	#print len(cve_list)
	for cve in cve_list:
		cve = [cve]
		cursor.execute("""SELECT * FROM cve_cluster_extend WHERE cve @> %s """,(list(cve),)) 
		rows = cursor.fetchall()
		if not rows:
	#		print "not find"
			continue
		for row in rows:	
			product = row[1]
			if not product in pre_products:
				continue
			versions = row[3]
			published = row[4]
			exploit = row[5]
			cluster_id = row[0]
			if row[7]:
				patched = min(row[7])####????
			else:
				patched = None
			clusters[product][cluster_id] = {"product": product, "published": published, "exploited": exploit, "patched": patched }
			versions = parse_version_list(versions)
			if not versions:
				continue
			products = products.union([product]) 
			cursor.execute("""select distinct product_line from release_date where product = %s """, (product,))
			product_lines = [tuple(line[0]) for line in cursor.fetchall()]
			#print versions
			#print product_lines
			
			version_lines = split_versions(versions, product_lines)
		
			#if product == 'chrome':
			#	print versions
			for line in version_lines:
				clusters[product][cluster_id][line] = ( min(version_lines[line]), max(version_lines[line]) )
			#	print clusters[cluster_id][line]
	### to each use
#	return 
#	print products
	cursor.execute(""" SELECT distinct machine_id FROM machine_isp; """)
	machine_ids  =[tmp[0] for tmp in  cursor.fetchall()]
#	machine_ids = [20639816]
	signals = {}
	total = len(machine_ids)
	products = ['firefox']
	count = 0
	for product in products:
#		print clusters[product]
		machine_lists = []	
		signal_list = []	
		#signal = [[] for i in range(total)]
		for idx, machine_id in enumerate(machine_ids):
			single_signal = []
			if idx % 1000 == 0:
				print count
				print "Process {}/{}".format(idx, total)
			cursor.execute("""SELECT product_lines, product_versions, timestamp FROM machine_state WHERE machine_id = {0} and  product = '{1}' ORDER BY timestamp, updated_line ; """.format(machine_id,product))
			rows = cursor.fetchall()
			if not rows:
				continue
			vul_clusters_old = set()
			for product_line, product_version in zip(rows[0][0], rows[0][1]):
				product_line = tuple(product_line)
				product_version = tuple(product_version)
				vul_clusters_old = vul_clusters_old.union([(cluster_id, cluster['published'], cluster['patched']) for cluster_id, cluster in clusters[product].items() if product_line in cluster and product_version >= cluster[product_line][0] and product_version <= cluster[product_line][1]])	
			for i in range(1, len(rows)):
				vul_clusters = set()
				for product_line, product_version in zip(rows[i][0], rows[i][1]):
					product_line = tuple(product_line)
					product_version = tuple(product_version)
					vul_clusters = vul_clusters.union([(cluster_id, cluster['published'], cluster['patched']) for cluster_id, cluster in clusters[product].items() if product_line in cluster and product_version >= cluster[product_line][0] and product_version <= cluster[product_line][1] ] )
				patch_clusters = vul_clusters_old - vul_clusters
				for cluster_id, published, patched in patch_clusters:
					#signal[idx].append(rows[i][2] - published)
					single_signal.append((rows[i][2] - published).days)
					count += 1
				vul_clusters_old = vul_clusters 
#			print signal[idx]
			machine_lists.append(machine_id)
			signal_list.append(single_signal)
		#signals[product] ={"signal" : signal, "machine_ids": machine_lists}
		sio.savemat(output, {"signal" : np.array(signal_list), 'machine_list': np.array(machine_lists)})


def add_patch_date():
	cursor.execute("""SELECT distinct product FROM release_date; """)
	rows =  cursor.fetchall()
	products = [row[0] for row in rows]
	products_lines = {}
	for product in products:
		cursor.execute("""SELECT distinct product_line FROM release_date WHERE product = %s """, (product,))
		rows = cursor.fetchall()
		products_lines[product] = [tuple(row[0]) for row in rows]
	cursor.execute("""SELECT * FROM cve_cluster where cluster_id = 3626; """)
	rows = cursor.fetchall()
	
	for row in rows:
		#print row
		version = row[3]
		product = row[1]
		if not products_lines.has_key(product):
			continue
		versions = parse_version_list(version)
		if not versions:
			continue
		#print "version:", versions 
		patch_date, patch_version = get_patch_date(product, products_lines[product], versions)
#		print patch_date,patch_version
		patch_version = combine_version(patch_version)
		cursor.execute(""" update cve_cluster_extend set patch_date = %s, patch_version = %s where cluster_id = {0}""".format(row[0]), (list(patch_date), list(patch_version)))
	conn.commit()

def combine_version(versions):
	tmp_versions = []
	for tmp_version in versions:
		tmp = ".".join(str(i) for i in tmp_version)
		tmp_versions.append(tmp)
	return tmp_versions 
def add_user_patch_date(product, product_lines, versions, machine_id):
	return True 	
				
def get_patch_date(product, product_lines, versions):
	patch_date = []
	patch_version = []
	version_lines = split_versions(versions, product_lines)
	for line in version_lines:
		max_version = max(version_lines[line])
		cursor.execute(""" SELECT date, version  FROM release_date WHERE product = %s AND product_line = %s AND version > %s ORDER BY version LIMIT 1; """, (product, list(line), list(max_version)))
		rows = cursor.fetchall()
		if rows:	
			patch_date.append(rows[0][0])
			patch_version.append(rows[0][1])
#		print product
#		print max_version
#		print line, patch_date
	if len(patch_date) == 0:
		max_version = max(versions)
		cursor.execute(""" SELECT date, version FROM release_date WHERE product = %s AND version > %s ORDER BY version LIMIT 1  ;""", (product, list(max_version)))
		rows = cursor.fetchall()
		if rows :
			patch_date.append(rows[0][0])
			patch_version.append(rows[0][1])
		#print patch_date
	return patch_date, patch_version
		

def split_versions(versions, product_lines):
	version_lines = {}
	for version in versions:
		product_line = [line for line in product_lines if (version +(0, ))[:len(line)] == line]
		if product_line :
			if product_line[0] in version_lines:
				version_lines[product_line[0]].append(version)
			else:
				version_lines[product_line[0]] = [version]

	return version_lines				

def parse_version_list(version_list):
	ignore_terms = ['a', 'b', 'preview_release', 'rc']
	versions = []
	for version in version_list:
		version = version.split(':', 1)
		if len(version)> 1:
			ignore = False
			for term in ignore_terms:
				if version[1].startswith(term):
					ignore = True
					break
			if ignore:
				continue
		try:
			versions.append(tuple(parse_version(version[0])))
		except Exception as e:
			continue
	return versions

def parse_version(version):
	version = list(map(int, version.split('.')))
	while not version[-1] and len(version) > 1:
		version.pop()
	return version
getPatchProfile("data/phish_cve", "phish_profile_signal")
